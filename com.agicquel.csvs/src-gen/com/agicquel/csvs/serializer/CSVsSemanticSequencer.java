/*
 * generated by Xtext 2.23.0
 */
package com.agicquel.csvs.serializer;

import com.agicquel.csvs.csvs.AddCommand;
import com.agicquel.csvs.csvs.And;
import com.agicquel.csvs.csvs.BoolConstant;
import com.agicquel.csvs.csvs.CellSelect;
import com.agicquel.csvs.csvs.ColSelect;
import com.agicquel.csvs.csvs.Command;
import com.agicquel.csvs.csvs.Comparison;
import com.agicquel.csvs.csvs.CountExpr;
import com.agicquel.csvs.csvs.CreateCommand;
import com.agicquel.csvs.csvs.CsvsPackage;
import com.agicquel.csvs.csvs.DeleteCommand;
import com.agicquel.csvs.csvs.Equality;
import com.agicquel.csvs.csvs.ExportCommand;
import com.agicquel.csvs.csvs.FieldSelect;
import com.agicquel.csvs.csvs.IfCommand;
import com.agicquel.csvs.csvs.IntConstant;
import com.agicquel.csvs.csvs.LoadCommand;
import com.agicquel.csvs.csvs.MulOrDiv;
import com.agicquel.csvs.csvs.Not;
import com.agicquel.csvs.csvs.Or;
import com.agicquel.csvs.csvs.Plus;
import com.agicquel.csvs.csvs.PrintCommand;
import com.agicquel.csvs.csvs.Program;
import com.agicquel.csvs.csvs.RowSelect;
import com.agicquel.csvs.csvs.SetCommand;
import com.agicquel.csvs.csvs.StoreCommand;
import com.agicquel.csvs.csvs.StringConstant;
import com.agicquel.csvs.csvs.VariableExpr;
import com.agicquel.csvs.csvs.WhileCommand;
import com.agicquel.csvs.services.CSVsGrammarAccess;
import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class CSVsSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private CSVsGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == CsvsPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case CsvsPackage.ADD_COMMAND:
				sequence_AddCommand(context, (AddCommand) semanticObject); 
				return; 
			case CsvsPackage.AND:
				sequence_And(context, (And) semanticObject); 
				return; 
			case CsvsPackage.BOOL_CONSTANT:
				sequence_Atomic(context, (BoolConstant) semanticObject); 
				return; 
			case CsvsPackage.CELL_SELECT:
				sequence_CellSelect(context, (CellSelect) semanticObject); 
				return; 
			case CsvsPackage.COL_SELECT:
				sequence_ColSelect(context, (ColSelect) semanticObject); 
				return; 
			case CsvsPackage.COMMAND:
				sequence_Command(context, (Command) semanticObject); 
				return; 
			case CsvsPackage.COMPARISON:
				sequence_Comparison(context, (Comparison) semanticObject); 
				return; 
			case CsvsPackage.COUNT_EXPR:
				sequence_CountExpr(context, (CountExpr) semanticObject); 
				return; 
			case CsvsPackage.CREATE_COMMAND:
				sequence_CreateCommand(context, (CreateCommand) semanticObject); 
				return; 
			case CsvsPackage.DELETE_COMMAND:
				sequence_DeleteCommand(context, (DeleteCommand) semanticObject); 
				return; 
			case CsvsPackage.EQUALITY:
				sequence_Equality(context, (Equality) semanticObject); 
				return; 
			case CsvsPackage.EXPORT_COMMAND:
				sequence_ExportCommand(context, (ExportCommand) semanticObject); 
				return; 
			case CsvsPackage.FIELD_SELECT:
				sequence_FieldSelect(context, (FieldSelect) semanticObject); 
				return; 
			case CsvsPackage.IF_COMMAND:
				sequence_IfCommand(context, (IfCommand) semanticObject); 
				return; 
			case CsvsPackage.INT_CONSTANT:
				sequence_Atomic(context, (IntConstant) semanticObject); 
				return; 
			case CsvsPackage.LOAD_COMMAND:
				sequence_LoadCommand(context, (LoadCommand) semanticObject); 
				return; 
			case CsvsPackage.MUL_OR_DIV:
				sequence_MulOrDiv(context, (MulOrDiv) semanticObject); 
				return; 
			case CsvsPackage.NOT:
				sequence_Primary(context, (Not) semanticObject); 
				return; 
			case CsvsPackage.OR:
				sequence_Or(context, (Or) semanticObject); 
				return; 
			case CsvsPackage.PLUS:
				sequence_PlusOrMinus(context, (Plus) semanticObject); 
				return; 
			case CsvsPackage.PRINT_COMMAND:
				sequence_PrintCommand(context, (PrintCommand) semanticObject); 
				return; 
			case CsvsPackage.PROGRAM:
				sequence_Program(context, (Program) semanticObject); 
				return; 
			case CsvsPackage.ROW_SELECT:
				sequence_RowSelect(context, (RowSelect) semanticObject); 
				return; 
			case CsvsPackage.SET_COMMAND:
				sequence_SetCommand(context, (SetCommand) semanticObject); 
				return; 
			case CsvsPackage.STORE_COMMAND:
				sequence_StoreCommand(context, (StoreCommand) semanticObject); 
				return; 
			case CsvsPackage.STRING_CONSTANT:
				sequence_Atomic(context, (StringConstant) semanticObject); 
				return; 
			case CsvsPackage.VARIABLE_EXPR:
				sequence_VariableExpr(context, (VariableExpr) semanticObject); 
				return; 
			case CsvsPackage.WHILE_COMMAND:
				sequence_WhileCommand(context, (WhileCommand) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Command returns AddCommand
	 *     CsvCommand returns AddCommand
	 *     AddCommand returns AddCommand
	 *
	 * Constraint:
	 *     ((op='row' | op='col') expression=Expression)
	 */
	protected void sequence_AddCommand(ISerializationContext context, AddCommand semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns And
	 *     Or returns And
	 *     Or.Or_1_0 returns And
	 *     And returns And
	 *     And.And_1_0 returns And
	 *     Equality returns And
	 *     Equality.Equality_1_0 returns And
	 *     Comparison returns And
	 *     Comparison.Comparison_1_0 returns And
	 *     PlusOrMinus returns And
	 *     PlusOrMinus.Plus_1_0_0 returns And
	 *     MulOrDiv returns And
	 *     MulOrDiv.MulOrDiv_1_0_0 returns And
	 *     Primary returns And
	 *
	 * Constraint:
	 *     (left=And_And_1_0 right=Equality)
	 */
	protected void sequence_And(ISerializationContext context, And semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CsvsPackage.Literals.AND__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsvsPackage.Literals.AND__LEFT));
			if (transientValues.isValueTransient(semanticObject, CsvsPackage.Literals.AND__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsvsPackage.Literals.AND__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAndAccess().getAndLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAndAccess().getRightEqualityParserRuleCall_1_4_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns BoolConstant
	 *     Or returns BoolConstant
	 *     Or.Or_1_0 returns BoolConstant
	 *     And returns BoolConstant
	 *     And.And_1_0 returns BoolConstant
	 *     Equality returns BoolConstant
	 *     Equality.Equality_1_0 returns BoolConstant
	 *     Comparison returns BoolConstant
	 *     Comparison.Comparison_1_0 returns BoolConstant
	 *     PlusOrMinus returns BoolConstant
	 *     PlusOrMinus.Plus_1_0_0 returns BoolConstant
	 *     MulOrDiv returns BoolConstant
	 *     MulOrDiv.MulOrDiv_1_0_0 returns BoolConstant
	 *     Primary returns BoolConstant
	 *     Atomic returns BoolConstant
	 *
	 * Constraint:
	 *     (value='true' | value='false')
	 */
	protected void sequence_Atomic(ISerializationContext context, BoolConstant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns IntConstant
	 *     Or returns IntConstant
	 *     Or.Or_1_0 returns IntConstant
	 *     And returns IntConstant
	 *     And.And_1_0 returns IntConstant
	 *     Equality returns IntConstant
	 *     Equality.Equality_1_0 returns IntConstant
	 *     Comparison returns IntConstant
	 *     Comparison.Comparison_1_0 returns IntConstant
	 *     PlusOrMinus returns IntConstant
	 *     PlusOrMinus.Plus_1_0_0 returns IntConstant
	 *     MulOrDiv returns IntConstant
	 *     MulOrDiv.MulOrDiv_1_0_0 returns IntConstant
	 *     Primary returns IntConstant
	 *     Atomic returns IntConstant
	 *
	 * Constraint:
	 *     value=INT
	 */
	protected void sequence_Atomic(ISerializationContext context, IntConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CsvsPackage.Literals.INT_CONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsvsPackage.Literals.INT_CONSTANT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getValueINTTerminalRuleCall_0_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns StringConstant
	 *     Or returns StringConstant
	 *     Or.Or_1_0 returns StringConstant
	 *     And returns StringConstant
	 *     And.And_1_0 returns StringConstant
	 *     Equality returns StringConstant
	 *     Equality.Equality_1_0 returns StringConstant
	 *     Comparison returns StringConstant
	 *     Comparison.Comparison_1_0 returns StringConstant
	 *     PlusOrMinus returns StringConstant
	 *     PlusOrMinus.Plus_1_0_0 returns StringConstant
	 *     MulOrDiv returns StringConstant
	 *     MulOrDiv.MulOrDiv_1_0_0 returns StringConstant
	 *     Primary returns StringConstant
	 *     Atomic returns StringConstant
	 *
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_Atomic(ISerializationContext context, StringConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CsvsPackage.Literals.STRING_CONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsvsPackage.Literals.STRING_CONSTANT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getValueSTRINGTerminalRuleCall_1_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns CellSelect
	 *     Selector returns CellSelect
	 *     CellSelect returns CellSelect
	 *     Or returns CellSelect
	 *     Or.Or_1_0 returns CellSelect
	 *     And returns CellSelect
	 *     And.And_1_0 returns CellSelect
	 *     Equality returns CellSelect
	 *     Equality.Equality_1_0 returns CellSelect
	 *     Comparison returns CellSelect
	 *     Comparison.Comparison_1_0 returns CellSelect
	 *     PlusOrMinus returns CellSelect
	 *     PlusOrMinus.Plus_1_0_0 returns CellSelect
	 *     MulOrDiv returns CellSelect
	 *     MulOrDiv.MulOrDiv_1_0_0 returns CellSelect
	 *     Primary returns CellSelect
	 *
	 * Constraint:
	 *     (var=ID expressionRow=Expression expressionCol=Expression)
	 */
	protected void sequence_CellSelect(ISerializationContext context, CellSelect semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CsvsPackage.Literals.SELECTOR__VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsvsPackage.Literals.SELECTOR__VAR));
			if (transientValues.isValueTransient(semanticObject, CsvsPackage.Literals.CELL_SELECT__EXPRESSION_ROW) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsvsPackage.Literals.CELL_SELECT__EXPRESSION_ROW));
			if (transientValues.isValueTransient(semanticObject, CsvsPackage.Literals.CELL_SELECT__EXPRESSION_COL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsvsPackage.Literals.CELL_SELECT__EXPRESSION_COL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCellSelectAccess().getVarIDTerminalRuleCall_2_0(), semanticObject.getVar());
		feeder.accept(grammarAccess.getCellSelectAccess().getExpressionRowExpressionParserRuleCall_6_0(), semanticObject.getExpressionRow());
		feeder.accept(grammarAccess.getCellSelectAccess().getExpressionColExpressionParserRuleCall_10_0(), semanticObject.getExpressionCol());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ColSelect
	 *     Selector returns ColSelect
	 *     ColSelect returns ColSelect
	 *     Or returns ColSelect
	 *     Or.Or_1_0 returns ColSelect
	 *     And returns ColSelect
	 *     And.And_1_0 returns ColSelect
	 *     Equality returns ColSelect
	 *     Equality.Equality_1_0 returns ColSelect
	 *     Comparison returns ColSelect
	 *     Comparison.Comparison_1_0 returns ColSelect
	 *     PlusOrMinus returns ColSelect
	 *     PlusOrMinus.Plus_1_0_0 returns ColSelect
	 *     MulOrDiv returns ColSelect
	 *     MulOrDiv.MulOrDiv_1_0_0 returns ColSelect
	 *     Primary returns ColSelect
	 *
	 * Constraint:
	 *     (var=ID expression=Expression)
	 */
	protected void sequence_ColSelect(ISerializationContext context, ColSelect semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CsvsPackage.Literals.SELECTOR__VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsvsPackage.Literals.SELECTOR__VAR));
			if (transientValues.isValueTransient(semanticObject, CsvsPackage.Literals.COL_SELECT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsvsPackage.Literals.COL_SELECT__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getColSelectAccess().getVarIDTerminalRuleCall_2_0(), semanticObject.getVar());
		feeder.accept(grammarAccess.getColSelectAccess().getExpressionExpressionParserRuleCall_6_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Command returns Command
	 *
	 * Constraint:
	 *     {Command}
	 */
	protected void sequence_Command(ISerializationContext context, Command semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Comparison
	 *     Or returns Comparison
	 *     Or.Or_1_0 returns Comparison
	 *     And returns Comparison
	 *     And.And_1_0 returns Comparison
	 *     Equality returns Comparison
	 *     Equality.Equality_1_0 returns Comparison
	 *     Comparison returns Comparison
	 *     Comparison.Comparison_1_0 returns Comparison
	 *     PlusOrMinus returns Comparison
	 *     PlusOrMinus.Plus_1_0_0 returns Comparison
	 *     MulOrDiv returns Comparison
	 *     MulOrDiv.MulOrDiv_1_0_0 returns Comparison
	 *     Primary returns Comparison
	 *
	 * Constraint:
	 *     (left=Comparison_Comparison_1_0 (op='>=' | op='<=' | op='>' | op='<') right=PlusOrMinus)
	 */
	protected void sequence_Comparison(ISerializationContext context, Comparison semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns CountExpr
	 *     CountExpr returns CountExpr
	 *     Or returns CountExpr
	 *     Or.Or_1_0 returns CountExpr
	 *     And returns CountExpr
	 *     And.And_1_0 returns CountExpr
	 *     Equality returns CountExpr
	 *     Equality.Equality_1_0 returns CountExpr
	 *     Comparison returns CountExpr
	 *     Comparison.Comparison_1_0 returns CountExpr
	 *     PlusOrMinus returns CountExpr
	 *     PlusOrMinus.Plus_1_0_0 returns CountExpr
	 *     MulOrDiv returns CountExpr
	 *     MulOrDiv.MulOrDiv_1_0_0 returns CountExpr
	 *     Primary returns CountExpr
	 *
	 * Constraint:
	 *     (var=ID expression=Expression)
	 */
	protected void sequence_CountExpr(ISerializationContext context, CountExpr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CsvsPackage.Literals.COUNT_EXPR__VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsvsPackage.Literals.COUNT_EXPR__VAR));
			if (transientValues.isValueTransient(semanticObject, CsvsPackage.Literals.COUNT_EXPR__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsvsPackage.Literals.COUNT_EXPR__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCountExprAccess().getVarIDTerminalRuleCall_2_0(), semanticObject.getVar());
		feeder.accept(grammarAccess.getCountExprAccess().getExpressionExpressionParserRuleCall_6_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Command returns CreateCommand
	 *     CsvCommand returns CreateCommand
	 *     CreateCommand returns CreateCommand
	 *
	 * Constraint:
	 *     var=ID
	 */
	protected void sequence_CreateCommand(ISerializationContext context, CreateCommand semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CsvsPackage.Literals.CREATE_COMMAND__VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsvsPackage.Literals.CREATE_COMMAND__VAR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCreateCommandAccess().getVarIDTerminalRuleCall_2_0(), semanticObject.getVar());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Command returns DeleteCommand
	 *     CsvCommand returns DeleteCommand
	 *     DeleteCommand returns DeleteCommand
	 *
	 * Constraint:
	 *     expression=Expression
	 */
	protected void sequence_DeleteCommand(ISerializationContext context, DeleteCommand semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CsvsPackage.Literals.DELETE_COMMAND__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsvsPackage.Literals.DELETE_COMMAND__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDeleteCommandAccess().getExpressionExpressionParserRuleCall_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Equality
	 *     Or returns Equality
	 *     Or.Or_1_0 returns Equality
	 *     And returns Equality
	 *     And.And_1_0 returns Equality
	 *     Equality returns Equality
	 *     Equality.Equality_1_0 returns Equality
	 *     Comparison returns Equality
	 *     Comparison.Comparison_1_0 returns Equality
	 *     PlusOrMinus returns Equality
	 *     PlusOrMinus.Plus_1_0_0 returns Equality
	 *     MulOrDiv returns Equality
	 *     MulOrDiv.MulOrDiv_1_0_0 returns Equality
	 *     Primary returns Equality
	 *
	 * Constraint:
	 *     (left=Equality_Equality_1_0 (op='==' | op='!=') right=Comparison)
	 */
	protected void sequence_Equality(ISerializationContext context, Equality semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Command returns ExportCommand
	 *     CsvCommand returns ExportCommand
	 *     ExportCommand returns ExportCommand
	 *
	 * Constraint:
	 *     expression=Expression
	 */
	protected void sequence_ExportCommand(ISerializationContext context, ExportCommand semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CsvsPackage.Literals.EXPORT_COMMAND__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsvsPackage.Literals.EXPORT_COMMAND__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExportCommandAccess().getExpressionExpressionParserRuleCall_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns FieldSelect
	 *     Selector returns FieldSelect
	 *     FieldSelect returns FieldSelect
	 *     Or returns FieldSelect
	 *     Or.Or_1_0 returns FieldSelect
	 *     And returns FieldSelect
	 *     And.And_1_0 returns FieldSelect
	 *     Equality returns FieldSelect
	 *     Equality.Equality_1_0 returns FieldSelect
	 *     Comparison returns FieldSelect
	 *     Comparison.Comparison_1_0 returns FieldSelect
	 *     PlusOrMinus returns FieldSelect
	 *     PlusOrMinus.Plus_1_0_0 returns FieldSelect
	 *     MulOrDiv returns FieldSelect
	 *     MulOrDiv.MulOrDiv_1_0_0 returns FieldSelect
	 *     Primary returns FieldSelect
	 *
	 * Constraint:
	 *     (var=ID expression=Expression)
	 */
	protected void sequence_FieldSelect(ISerializationContext context, FieldSelect semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CsvsPackage.Literals.SELECTOR__VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsvsPackage.Literals.SELECTOR__VAR));
			if (transientValues.isValueTransient(semanticObject, CsvsPackage.Literals.FIELD_SELECT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsvsPackage.Literals.FIELD_SELECT__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFieldSelectAccess().getVarIDTerminalRuleCall_2_0(), semanticObject.getVar());
		feeder.accept(grammarAccess.getFieldSelectAccess().getExpressionExpressionParserRuleCall_6_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Command returns IfCommand
	 *     ControlCommand returns IfCommand
	 *     IfCommand returns IfCommand
	 *
	 * Constraint:
	 *     (cond=Expression thenBody=Block elseBody=Block?)
	 */
	protected void sequence_IfCommand(ISerializationContext context, IfCommand semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Command returns LoadCommand
	 *     CsvCommand returns LoadCommand
	 *     LoadCommand returns LoadCommand
	 *
	 * Constraint:
	 *     var=ID
	 */
	protected void sequence_LoadCommand(ISerializationContext context, LoadCommand semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CsvsPackage.Literals.LOAD_COMMAND__VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsvsPackage.Literals.LOAD_COMMAND__VAR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLoadCommandAccess().getVarIDTerminalRuleCall_2_0(), semanticObject.getVar());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns MulOrDiv
	 *     Or returns MulOrDiv
	 *     Or.Or_1_0 returns MulOrDiv
	 *     And returns MulOrDiv
	 *     And.And_1_0 returns MulOrDiv
	 *     Equality returns MulOrDiv
	 *     Equality.Equality_1_0 returns MulOrDiv
	 *     Comparison returns MulOrDiv
	 *     Comparison.Comparison_1_0 returns MulOrDiv
	 *     PlusOrMinus returns MulOrDiv
	 *     PlusOrMinus.Plus_1_0_0 returns MulOrDiv
	 *     MulOrDiv returns MulOrDiv
	 *     MulOrDiv.MulOrDiv_1_0_0 returns MulOrDiv
	 *     Primary returns MulOrDiv
	 *
	 * Constraint:
	 *     (left=MulOrDiv_MulOrDiv_1_0_0 (op='*' | op='/') right=Primary)
	 */
	protected void sequence_MulOrDiv(ISerializationContext context, MulOrDiv semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Or
	 *     Or returns Or
	 *     Or.Or_1_0 returns Or
	 *     And returns Or
	 *     And.And_1_0 returns Or
	 *     Equality returns Or
	 *     Equality.Equality_1_0 returns Or
	 *     Comparison returns Or
	 *     Comparison.Comparison_1_0 returns Or
	 *     PlusOrMinus returns Or
	 *     PlusOrMinus.Plus_1_0_0 returns Or
	 *     MulOrDiv returns Or
	 *     MulOrDiv.MulOrDiv_1_0_0 returns Or
	 *     Primary returns Or
	 *
	 * Constraint:
	 *     (left=Or_Or_1_0 right=And)
	 */
	protected void sequence_Or(ISerializationContext context, Or semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CsvsPackage.Literals.OR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsvsPackage.Literals.OR__LEFT));
			if (transientValues.isValueTransient(semanticObject, CsvsPackage.Literals.OR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsvsPackage.Literals.OR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOrAccess().getOrLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getOrAccess().getRightAndParserRuleCall_1_4_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Plus
	 *     Or returns Plus
	 *     Or.Or_1_0 returns Plus
	 *     And returns Plus
	 *     And.And_1_0 returns Plus
	 *     Equality returns Plus
	 *     Equality.Equality_1_0 returns Plus
	 *     Comparison returns Plus
	 *     Comparison.Comparison_1_0 returns Plus
	 *     PlusOrMinus returns Plus
	 *     PlusOrMinus.Plus_1_0_0 returns Plus
	 *     MulOrDiv returns Plus
	 *     MulOrDiv.MulOrDiv_1_0_0 returns Plus
	 *     Primary returns Plus
	 *
	 * Constraint:
	 *     (left=PlusOrMinus_Plus_1_0_0 (op='+' | op='-') right=MulOrDiv)
	 */
	protected void sequence_PlusOrMinus(ISerializationContext context, Plus semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Not
	 *     Or returns Not
	 *     Or.Or_1_0 returns Not
	 *     And returns Not
	 *     And.And_1_0 returns Not
	 *     Equality returns Not
	 *     Equality.Equality_1_0 returns Not
	 *     Comparison returns Not
	 *     Comparison.Comparison_1_0 returns Not
	 *     PlusOrMinus returns Not
	 *     PlusOrMinus.Plus_1_0_0 returns Not
	 *     MulOrDiv returns Not
	 *     MulOrDiv.MulOrDiv_1_0_0 returns Not
	 *     Primary returns Not
	 *
	 * Constraint:
	 *     expression=Primary
	 */
	protected void sequence_Primary(ISerializationContext context, Not semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CsvsPackage.Literals.NOT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsvsPackage.Literals.NOT__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimaryAccess().getExpressionPrimaryParserRuleCall_1_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Command returns PrintCommand
	 *     CsvCommand returns PrintCommand
	 *     PrintCommand returns PrintCommand
	 *
	 * Constraint:
	 *     expression=Expression
	 */
	protected void sequence_PrintCommand(ISerializationContext context, PrintCommand semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CsvsPackage.Literals.PRINT_COMMAND__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsvsPackage.Literals.PRINT_COMMAND__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrintCommandAccess().getExpressionExpressionParserRuleCall_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Program returns Program
	 *     Block returns Program
	 *
	 * Constraint:
	 *     commands+=Command+
	 */
	protected void sequence_Program(ISerializationContext context, Program semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns RowSelect
	 *     Selector returns RowSelect
	 *     RowSelect returns RowSelect
	 *     Or returns RowSelect
	 *     Or.Or_1_0 returns RowSelect
	 *     And returns RowSelect
	 *     And.And_1_0 returns RowSelect
	 *     Equality returns RowSelect
	 *     Equality.Equality_1_0 returns RowSelect
	 *     Comparison returns RowSelect
	 *     Comparison.Comparison_1_0 returns RowSelect
	 *     PlusOrMinus returns RowSelect
	 *     PlusOrMinus.Plus_1_0_0 returns RowSelect
	 *     MulOrDiv returns RowSelect
	 *     MulOrDiv.MulOrDiv_1_0_0 returns RowSelect
	 *     Primary returns RowSelect
	 *
	 * Constraint:
	 *     (var=ID expression=Expression)
	 */
	protected void sequence_RowSelect(ISerializationContext context, RowSelect semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CsvsPackage.Literals.SELECTOR__VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsvsPackage.Literals.SELECTOR__VAR));
			if (transientValues.isValueTransient(semanticObject, CsvsPackage.Literals.ROW_SELECT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsvsPackage.Literals.ROW_SELECT__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRowSelectAccess().getVarIDTerminalRuleCall_2_0(), semanticObject.getVar());
		feeder.accept(grammarAccess.getRowSelectAccess().getExpressionExpressionParserRuleCall_6_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Command returns SetCommand
	 *     CsvCommand returns SetCommand
	 *     SetCommand returns SetCommand
	 *
	 * Constraint:
	 *     (var=Expression expression=Expression)
	 */
	protected void sequence_SetCommand(ISerializationContext context, SetCommand semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CsvsPackage.Literals.SET_COMMAND__VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsvsPackage.Literals.SET_COMMAND__VAR));
			if (transientValues.isValueTransient(semanticObject, CsvsPackage.Literals.SET_COMMAND__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsvsPackage.Literals.SET_COMMAND__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSetCommandAccess().getVarExpressionParserRuleCall_2_0(), semanticObject.getVar());
		feeder.accept(grammarAccess.getSetCommandAccess().getExpressionExpressionParserRuleCall_4_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Command returns StoreCommand
	 *     CsvCommand returns StoreCommand
	 *     StoreCommand returns StoreCommand
	 *
	 * Constraint:
	 *     var=ID
	 */
	protected void sequence_StoreCommand(ISerializationContext context, StoreCommand semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CsvsPackage.Literals.STORE_COMMAND__VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsvsPackage.Literals.STORE_COMMAND__VAR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStoreCommandAccess().getVarIDTerminalRuleCall_2_0(), semanticObject.getVar());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns VariableExpr
	 *     VariableExpr returns VariableExpr
	 *     Or returns VariableExpr
	 *     Or.Or_1_0 returns VariableExpr
	 *     And returns VariableExpr
	 *     And.And_1_0 returns VariableExpr
	 *     Equality returns VariableExpr
	 *     Equality.Equality_1_0 returns VariableExpr
	 *     Comparison returns VariableExpr
	 *     Comparison.Comparison_1_0 returns VariableExpr
	 *     PlusOrMinus returns VariableExpr
	 *     PlusOrMinus.Plus_1_0_0 returns VariableExpr
	 *     MulOrDiv returns VariableExpr
	 *     MulOrDiv.MulOrDiv_1_0_0 returns VariableExpr
	 *     Primary returns VariableExpr
	 *     Atomic returns VariableExpr
	 *
	 * Constraint:
	 *     term=ID
	 */
	protected void sequence_VariableExpr(ISerializationContext context, VariableExpr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CsvsPackage.Literals.VARIABLE_EXPR__TERM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsvsPackage.Literals.VARIABLE_EXPR__TERM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableExprAccess().getTermIDTerminalRuleCall_0(), semanticObject.getTerm());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Command returns WhileCommand
	 *     ControlCommand returns WhileCommand
	 *     WhileCommand returns WhileCommand
	 *
	 * Constraint:
	 *     (cond=Expression body=Block)
	 */
	protected void sequence_WhileCommand(ISerializationContext context, WhileCommand semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CsvsPackage.Literals.CONTROL_COMMAND__COND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsvsPackage.Literals.CONTROL_COMMAND__COND));
			if (transientValues.isValueTransient(semanticObject, CsvsPackage.Literals.WHILE_COMMAND__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsvsPackage.Literals.WHILE_COMMAND__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getWhileCommandAccess().getCondExpressionParserRuleCall_4_0(), semanticObject.getCond());
		feeder.accept(grammarAccess.getWhileCommandAccess().getBodyBlockParserRuleCall_8_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
}
