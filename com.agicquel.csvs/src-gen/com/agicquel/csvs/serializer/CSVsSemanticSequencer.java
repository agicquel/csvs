/*
 * generated by Xtext 2.23.0
 */
package com.agicquel.csvs.serializer;

import com.agicquel.csvs.csvs.AddCommand;
import com.agicquel.csvs.csvs.AddExpr;
import com.agicquel.csvs.csvs.ApplyCommand;
import com.agicquel.csvs.csvs.ApplyExecCommand;
import com.agicquel.csvs.csvs.ApplyFilterCommand;
import com.agicquel.csvs.csvs.Block;
import com.agicquel.csvs.csvs.BoolConstant;
import com.agicquel.csvs.csvs.CellSelect;
import com.agicquel.csvs.csvs.ColSelect;
import com.agicquel.csvs.csvs.Command;
import com.agicquel.csvs.csvs.ComparaisonExpr;
import com.agicquel.csvs.csvs.CountExpr;
import com.agicquel.csvs.csvs.CreateCommand;
import com.agicquel.csvs.csvs.CsvsPackage;
import com.agicquel.csvs.csvs.DeleteCommand;
import com.agicquel.csvs.csvs.EqualityExpr;
import com.agicquel.csvs.csvs.ExportCommand;
import com.agicquel.csvs.csvs.FieldSelect;
import com.agicquel.csvs.csvs.IfCommand;
import com.agicquel.csvs.csvs.IntConstant;
import com.agicquel.csvs.csvs.LoadCommand;
import com.agicquel.csvs.csvs.Model;
import com.agicquel.csvs.csvs.MulOrDivExpr;
import com.agicquel.csvs.csvs.NotExpr;
import com.agicquel.csvs.csvs.OrExpr;
import com.agicquel.csvs.csvs.PlusOrMinusExpr;
import com.agicquel.csvs.csvs.PrintCommand;
import com.agicquel.csvs.csvs.RowSelect;
import com.agicquel.csvs.csvs.SetCommand;
import com.agicquel.csvs.csvs.StoreCommand;
import com.agicquel.csvs.csvs.StringConstant;
import com.agicquel.csvs.csvs.VariableSelect;
import com.agicquel.csvs.csvs.WhileCommand;
import com.agicquel.csvs.services.CSVsGrammarAccess;
import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class CSVsSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private CSVsGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == CsvsPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case CsvsPackage.ADD_COMMAND:
				sequence_AddCommand(context, (AddCommand) semanticObject); 
				return; 
			case CsvsPackage.ADD_EXPR:
				sequence_AddExpr(context, (AddExpr) semanticObject); 
				return; 
			case CsvsPackage.APPLY_COMMAND:
				sequence_ApplyCommand(context, (ApplyCommand) semanticObject); 
				return; 
			case CsvsPackage.APPLY_EXEC_COMMAND:
				sequence_ApplyExecCommand(context, (ApplyExecCommand) semanticObject); 
				return; 
			case CsvsPackage.APPLY_FILTER_COMMAND:
				sequence_ApplyFilterCommand(context, (ApplyFilterCommand) semanticObject); 
				return; 
			case CsvsPackage.BLOCK:
				sequence_Block(context, (Block) semanticObject); 
				return; 
			case CsvsPackage.BOOL_CONSTANT:
				sequence_AtomicExpr(context, (BoolConstant) semanticObject); 
				return; 
			case CsvsPackage.CELL_SELECT:
				sequence_CellSelect(context, (CellSelect) semanticObject); 
				return; 
			case CsvsPackage.COL_SELECT:
				sequence_ColSelect(context, (ColSelect) semanticObject); 
				return; 
			case CsvsPackage.COMMAND:
				sequence_Command(context, (Command) semanticObject); 
				return; 
			case CsvsPackage.COMPARAISON_EXPR:
				sequence_ComparaisonExpr(context, (ComparaisonExpr) semanticObject); 
				return; 
			case CsvsPackage.COUNT_EXPR:
				sequence_CountExpr(context, (CountExpr) semanticObject); 
				return; 
			case CsvsPackage.CREATE_COMMAND:
				sequence_CreateCommand(context, (CreateCommand) semanticObject); 
				return; 
			case CsvsPackage.DELETE_COMMAND:
				sequence_DeleteCommand(context, (DeleteCommand) semanticObject); 
				return; 
			case CsvsPackage.EQUALITY_EXPR:
				sequence_EqualityExpr(context, (EqualityExpr) semanticObject); 
				return; 
			case CsvsPackage.EXPORT_COMMAND:
				sequence_ExportCommand(context, (ExportCommand) semanticObject); 
				return; 
			case CsvsPackage.FIELD_SELECT:
				sequence_FieldSelect(context, (FieldSelect) semanticObject); 
				return; 
			case CsvsPackage.IF_COMMAND:
				sequence_IfCommand(context, (IfCommand) semanticObject); 
				return; 
			case CsvsPackage.INT_CONSTANT:
				sequence_AtomicExpr(context, (IntConstant) semanticObject); 
				return; 
			case CsvsPackage.LOAD_COMMAND:
				sequence_LoadCommand(context, (LoadCommand) semanticObject); 
				return; 
			case CsvsPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case CsvsPackage.MUL_OR_DIV_EXPR:
				sequence_MulOrDivExpr(context, (MulOrDivExpr) semanticObject); 
				return; 
			case CsvsPackage.NOT_EXPR:
				sequence_NotExpr(context, (NotExpr) semanticObject); 
				return; 
			case CsvsPackage.OR_EXPR:
				sequence_OrExpr(context, (OrExpr) semanticObject); 
				return; 
			case CsvsPackage.PLUS_OR_MINUS_EXPR:
				sequence_PlusOrMinusExpr(context, (PlusOrMinusExpr) semanticObject); 
				return; 
			case CsvsPackage.PRINT_COMMAND:
				sequence_PrintCommand(context, (PrintCommand) semanticObject); 
				return; 
			case CsvsPackage.ROW_SELECT:
				sequence_RowSelect(context, (RowSelect) semanticObject); 
				return; 
			case CsvsPackage.SET_COMMAND:
				sequence_SetCommand(context, (SetCommand) semanticObject); 
				return; 
			case CsvsPackage.STORE_COMMAND:
				sequence_StoreCommand(context, (StoreCommand) semanticObject); 
				return; 
			case CsvsPackage.STRING_CONSTANT:
				sequence_AtomicExpr(context, (StringConstant) semanticObject); 
				return; 
			case CsvsPackage.VARIABLE_SELECT:
				sequence_VariableSelect(context, (VariableSelect) semanticObject); 
				return; 
			case CsvsPackage.WHILE_COMMAND:
				sequence_WhileCommand(context, (WhileCommand) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Command returns AddCommand
	 *     CsvCommand returns AddCommand
	 *     AddCommand returns AddCommand
	 *
	 * Constraint:
	 *     ((op='row' | op='col') expression=Expression)
	 */
	protected void sequence_AddCommand(ISerializationContext context, AddCommand semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AddExpr returns AddExpr
	 *
	 * Constraint:
	 *     (left=EqualityExpr right+=EqualityExpr*)
	 */
	protected void sequence_AddExpr(ISerializationContext context, AddExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Command returns ApplyCommand
	 *     CsvCommand returns ApplyCommand
	 *     ApplyCommand returns ApplyCommand
	 *
	 * Constraint:
	 *     (selection=Selector if=ApplyFilterCommand? exec=ApplyExecCommand)
	 */
	protected void sequence_ApplyCommand(ISerializationContext context, ApplyCommand semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ApplyExecCommand returns ApplyExecCommand
	 *
	 * Constraint:
	 *     (varName=ID expr=Expression)
	 */
	protected void sequence_ApplyExecCommand(ISerializationContext context, ApplyExecCommand semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CsvsPackage.Literals.APPLY_EXEC_COMMAND__VAR_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsvsPackage.Literals.APPLY_EXEC_COMMAND__VAR_NAME));
			if (transientValues.isValueTransient(semanticObject, CsvsPackage.Literals.APPLY_EXEC_COMMAND__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsvsPackage.Literals.APPLY_EXEC_COMMAND__EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getApplyExecCommandAccess().getVarNameIDTerminalRuleCall_4_0(), semanticObject.getVarName());
		feeder.accept(grammarAccess.getApplyExecCommandAccess().getExprExpressionParserRuleCall_8_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ApplyFilterCommand returns ApplyFilterCommand
	 *
	 * Constraint:
	 *     (varName=ID expr=Expression)
	 */
	protected void sequence_ApplyFilterCommand(ISerializationContext context, ApplyFilterCommand semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CsvsPackage.Literals.APPLY_FILTER_COMMAND__VAR_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsvsPackage.Literals.APPLY_FILTER_COMMAND__VAR_NAME));
			if (transientValues.isValueTransient(semanticObject, CsvsPackage.Literals.APPLY_FILTER_COMMAND__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsvsPackage.Literals.APPLY_FILTER_COMMAND__EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getApplyFilterCommandAccess().getVarNameIDTerminalRuleCall_4_0(), semanticObject.getVarName());
		feeder.accept(grammarAccess.getApplyFilterCommandAccess().getExprExpressionParserRuleCall_8_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PrimaryExpr returns BoolConstant
	 *     AtomicExpr returns BoolConstant
	 *
	 * Constraint:
	 *     (value='true' | value='false')
	 */
	protected void sequence_AtomicExpr(ISerializationContext context, BoolConstant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PrimaryExpr returns IntConstant
	 *     AtomicExpr returns IntConstant
	 *
	 * Constraint:
	 *     value=INT
	 */
	protected void sequence_AtomicExpr(ISerializationContext context, IntConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CsvsPackage.Literals.INT_CONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsvsPackage.Literals.INT_CONSTANT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicExprAccess().getValueINTTerminalRuleCall_0_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PrimaryExpr returns StringConstant
	 *     AtomicExpr returns StringConstant
	 *
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_AtomicExpr(ISerializationContext context, StringConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CsvsPackage.Literals.STRING_CONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsvsPackage.Literals.STRING_CONSTANT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicExprAccess().getValueSTRINGTerminalRuleCall_1_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Block returns Block
	 *
	 * Constraint:
	 *     commands+=Command+
	 */
	protected void sequence_Block(ISerializationContext context, Block semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Selector returns CellSelect
	 *     CellSelect returns CellSelect
	 *     PrimaryExpr returns CellSelect
	 *
	 * Constraint:
	 *     (var=ID expressionRow=PrimaryExpr expressionCol=PrimaryExpr)
	 */
	protected void sequence_CellSelect(ISerializationContext context, CellSelect semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CsvsPackage.Literals.CELL_SELECT__VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsvsPackage.Literals.CELL_SELECT__VAR));
			if (transientValues.isValueTransient(semanticObject, CsvsPackage.Literals.CELL_SELECT__EXPRESSION_ROW) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsvsPackage.Literals.CELL_SELECT__EXPRESSION_ROW));
			if (transientValues.isValueTransient(semanticObject, CsvsPackage.Literals.CELL_SELECT__EXPRESSION_COL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsvsPackage.Literals.CELL_SELECT__EXPRESSION_COL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCellSelectAccess().getVarIDTerminalRuleCall_2_0(), semanticObject.getVar());
		feeder.accept(grammarAccess.getCellSelectAccess().getExpressionRowPrimaryExprParserRuleCall_6_0(), semanticObject.getExpressionRow());
		feeder.accept(grammarAccess.getCellSelectAccess().getExpressionColPrimaryExprParserRuleCall_10_0(), semanticObject.getExpressionCol());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Selector returns ColSelect
	 *     ColSelect returns ColSelect
	 *     PrimaryExpr returns ColSelect
	 *
	 * Constraint:
	 *     (var=ID expression=PrimaryExpr)
	 */
	protected void sequence_ColSelect(ISerializationContext context, ColSelect semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CsvsPackage.Literals.COL_SELECT__VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsvsPackage.Literals.COL_SELECT__VAR));
			if (transientValues.isValueTransient(semanticObject, CsvsPackage.Literals.COL_SELECT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsvsPackage.Literals.COL_SELECT__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getColSelectAccess().getVarIDTerminalRuleCall_2_0(), semanticObject.getVar());
		feeder.accept(grammarAccess.getColSelectAccess().getExpressionPrimaryExprParserRuleCall_6_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Command returns Command
	 *
	 * Constraint:
	 *     {Command}
	 */
	protected void sequence_Command(ISerializationContext context, Command semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ComparaisonExpr returns ComparaisonExpr
	 *
	 * Constraint:
	 *     (left=PlusOrMinusExpr ((op='>=' | op='<=' | op='>' | op='<') right=PlusOrMinusExpr)?)
	 */
	protected void sequence_ComparaisonExpr(ISerializationContext context, ComparaisonExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CountExpr returns CountExpr
	 *     PrimaryExpr returns CountExpr
	 *
	 * Constraint:
	 *     expression=PrimaryExpr
	 */
	protected void sequence_CountExpr(ISerializationContext context, CountExpr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CsvsPackage.Literals.COUNT_EXPR__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsvsPackage.Literals.COUNT_EXPR__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCountExprAccess().getExpressionPrimaryExprParserRuleCall_4_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Command returns CreateCommand
	 *     CsvCommand returns CreateCommand
	 *     CreateCommand returns CreateCommand
	 *
	 * Constraint:
	 *     var=ID
	 */
	protected void sequence_CreateCommand(ISerializationContext context, CreateCommand semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CsvsPackage.Literals.CREATE_COMMAND__VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsvsPackage.Literals.CREATE_COMMAND__VAR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCreateCommandAccess().getVarIDTerminalRuleCall_2_0(), semanticObject.getVar());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Command returns DeleteCommand
	 *     CsvCommand returns DeleteCommand
	 *     DeleteCommand returns DeleteCommand
	 *
	 * Constraint:
	 *     expression=Expression
	 */
	protected void sequence_DeleteCommand(ISerializationContext context, DeleteCommand semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CsvsPackage.Literals.DELETE_COMMAND__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsvsPackage.Literals.DELETE_COMMAND__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDeleteCommandAccess().getExpressionExpressionParserRuleCall_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EqualityExpr returns EqualityExpr
	 *
	 * Constraint:
	 *     (left=ComparaisonExpr ((op='==' | op='!=') right=ComparaisonExpr)?)
	 */
	protected void sequence_EqualityExpr(ISerializationContext context, EqualityExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Command returns ExportCommand
	 *     CsvCommand returns ExportCommand
	 *     ExportCommand returns ExportCommand
	 *
	 * Constraint:
	 *     (var=ID path=STRING)
	 */
	protected void sequence_ExportCommand(ISerializationContext context, ExportCommand semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CsvsPackage.Literals.EXPORT_COMMAND__VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsvsPackage.Literals.EXPORT_COMMAND__VAR));
			if (transientValues.isValueTransient(semanticObject, CsvsPackage.Literals.EXPORT_COMMAND__PATH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsvsPackage.Literals.EXPORT_COMMAND__PATH));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExportCommandAccess().getVarIDTerminalRuleCall_2_0(), semanticObject.getVar());
		feeder.accept(grammarAccess.getExportCommandAccess().getPathSTRINGTerminalRuleCall_4_0(), semanticObject.getPath());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Selector returns FieldSelect
	 *     FieldSelect returns FieldSelect
	 *     PrimaryExpr returns FieldSelect
	 *
	 * Constraint:
	 *     (var=ID expression=PrimaryExpr)
	 */
	protected void sequence_FieldSelect(ISerializationContext context, FieldSelect semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CsvsPackage.Literals.FIELD_SELECT__VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsvsPackage.Literals.FIELD_SELECT__VAR));
			if (transientValues.isValueTransient(semanticObject, CsvsPackage.Literals.FIELD_SELECT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsvsPackage.Literals.FIELD_SELECT__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFieldSelectAccess().getVarIDTerminalRuleCall_2_0(), semanticObject.getVar());
		feeder.accept(grammarAccess.getFieldSelectAccess().getExpressionPrimaryExprParserRuleCall_6_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Command returns IfCommand
	 *     ControlCommand returns IfCommand
	 *     IfCommand returns IfCommand
	 *
	 * Constraint:
	 *     (cond=Expression thenBody=Block elseBody=Block?)
	 */
	protected void sequence_IfCommand(ISerializationContext context, IfCommand semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Command returns LoadCommand
	 *     CsvCommand returns LoadCommand
	 *     LoadCommand returns LoadCommand
	 *
	 * Constraint:
	 *     (var=ID path=STRING)
	 */
	protected void sequence_LoadCommand(ISerializationContext context, LoadCommand semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CsvsPackage.Literals.LOAD_COMMAND__VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsvsPackage.Literals.LOAD_COMMAND__VAR));
			if (transientValues.isValueTransient(semanticObject, CsvsPackage.Literals.LOAD_COMMAND__PATH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsvsPackage.Literals.LOAD_COMMAND__PATH));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLoadCommandAccess().getVarIDTerminalRuleCall_2_0(), semanticObject.getVar());
		feeder.accept(grammarAccess.getLoadCommandAccess().getPathSTRINGTerminalRuleCall_4_0(), semanticObject.getPath());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     commands+=Command+
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MulOrDivExpr returns MulOrDivExpr
	 *
	 * Constraint:
	 *     (left=PrimaryExpr ((op+='*' | op+='/' | op+='%') right+=PrimaryExpr)*)
	 */
	protected void sequence_MulOrDivExpr(ISerializationContext context, MulOrDivExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PrimaryExpr returns NotExpr
	 *     NotExpr returns NotExpr
	 *
	 * Constraint:
	 *     expr=PrimaryExpr
	 */
	protected void sequence_NotExpr(ISerializationContext context, NotExpr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CsvsPackage.Literals.NOT_EXPR__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsvsPackage.Literals.NOT_EXPR__EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNotExprAccess().getExprPrimaryExprParserRuleCall_2_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns OrExpr
	 *     OrExpr returns OrExpr
	 *     PrimaryExpr returns OrExpr
	 *
	 * Constraint:
	 *     (left=AddExpr right+=AddExpr*)
	 */
	protected void sequence_OrExpr(ISerializationContext context, OrExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PlusOrMinusExpr returns PlusOrMinusExpr
	 *
	 * Constraint:
	 *     (left=MulOrDivExpr ((op+='+' | op+='-') right+=MulOrDivExpr)*)
	 */
	protected void sequence_PlusOrMinusExpr(ISerializationContext context, PlusOrMinusExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Command returns PrintCommand
	 *     CsvCommand returns PrintCommand
	 *     PrintCommand returns PrintCommand
	 *
	 * Constraint:
	 *     expression=Expression
	 */
	protected void sequence_PrintCommand(ISerializationContext context, PrintCommand semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CsvsPackage.Literals.PRINT_COMMAND__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsvsPackage.Literals.PRINT_COMMAND__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrintCommandAccess().getExpressionExpressionParserRuleCall_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Selector returns RowSelect
	 *     RowSelect returns RowSelect
	 *     PrimaryExpr returns RowSelect
	 *
	 * Constraint:
	 *     (var=ID expression=PrimaryExpr)
	 */
	protected void sequence_RowSelect(ISerializationContext context, RowSelect semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CsvsPackage.Literals.ROW_SELECT__VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsvsPackage.Literals.ROW_SELECT__VAR));
			if (transientValues.isValueTransient(semanticObject, CsvsPackage.Literals.ROW_SELECT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsvsPackage.Literals.ROW_SELECT__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRowSelectAccess().getVarIDTerminalRuleCall_2_0(), semanticObject.getVar());
		feeder.accept(grammarAccess.getRowSelectAccess().getExpressionPrimaryExprParserRuleCall_6_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Command returns SetCommand
	 *     CsvCommand returns SetCommand
	 *     SetCommand returns SetCommand
	 *
	 * Constraint:
	 *     (var=Selector expression=Expression)
	 */
	protected void sequence_SetCommand(ISerializationContext context, SetCommand semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CsvsPackage.Literals.SET_COMMAND__VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsvsPackage.Literals.SET_COMMAND__VAR));
			if (transientValues.isValueTransient(semanticObject, CsvsPackage.Literals.SET_COMMAND__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsvsPackage.Literals.SET_COMMAND__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSetCommandAccess().getVarSelectorParserRuleCall_0_0(), semanticObject.getVar());
		feeder.accept(grammarAccess.getSetCommandAccess().getExpressionExpressionParserRuleCall_4_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Command returns StoreCommand
	 *     CsvCommand returns StoreCommand
	 *     StoreCommand returns StoreCommand
	 *
	 * Constraint:
	 *     (var=ID path=STRING)
	 */
	protected void sequence_StoreCommand(ISerializationContext context, StoreCommand semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CsvsPackage.Literals.STORE_COMMAND__VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsvsPackage.Literals.STORE_COMMAND__VAR));
			if (transientValues.isValueTransient(semanticObject, CsvsPackage.Literals.STORE_COMMAND__PATH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsvsPackage.Literals.STORE_COMMAND__PATH));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStoreCommandAccess().getVarIDTerminalRuleCall_2_0(), semanticObject.getVar());
		feeder.accept(grammarAccess.getStoreCommandAccess().getPathSTRINGTerminalRuleCall_4_0(), semanticObject.getPath());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Selector returns VariableSelect
	 *     VariableSelect returns VariableSelect
	 *     PrimaryExpr returns VariableSelect
	 *
	 * Constraint:
	 *     term=ID
	 */
	protected void sequence_VariableSelect(ISerializationContext context, VariableSelect semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CsvsPackage.Literals.VARIABLE_SELECT__TERM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsvsPackage.Literals.VARIABLE_SELECT__TERM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableSelectAccess().getTermIDTerminalRuleCall_0(), semanticObject.getTerm());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Command returns WhileCommand
	 *     ControlCommand returns WhileCommand
	 *     WhileCommand returns WhileCommand
	 *
	 * Constraint:
	 *     (cond=Expression body=Block)
	 */
	protected void sequence_WhileCommand(ISerializationContext context, WhileCommand semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CsvsPackage.Literals.CONTROL_COMMAND__COND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsvsPackage.Literals.CONTROL_COMMAND__COND));
			if (transientValues.isValueTransient(semanticObject, CsvsPackage.Literals.WHILE_COMMAND__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsvsPackage.Literals.WHILE_COMMAND__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getWhileCommandAccess().getCondExpressionParserRuleCall_4_0(), semanticObject.getCond());
		feeder.accept(grammarAccess.getWhileCommandAccess().getBodyBlockParserRuleCall_8_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
}
